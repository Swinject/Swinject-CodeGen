#!/usr/bin/env ruby
require "erb"
require "Shellwords"
require "optparse"
require_relative "./CSVParser"
require_relative "./YMLParser"
require_relative "./YMLSerializer"

@options = {
  :MIGRATION  => false,
  :CONVERT  => false,
  :INPUT_FILE => nil,
  :OUTPUT_FILE => nil
}

@parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{__FILE__} [options]"

  opts.on("-iINPUT", "--input=INPUT", "The file containing the definitions, currently .yml and .csv are supported (separated by semicolon).") do |i|
    @options[:INPUT_FILE] = i
  end

  opts.on("-oOUTPUT", "--output=OUTPUT", "The file to write to. Use STDOUT if not given") do |o|
    @options[:OUTPUT_FILE] = o
  end

  opts.on("-m", "--migration", "Generate migration.sh files to automatically replace existing calls in swift code.") do |v|
    @options[:MIGRATION] = true
  end

  opts.on("-c", "--convert", "Convert the input file into the other format") do |v|
    @options[:CONVERT] = true
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end

def main
  @parser.parse!

  inputFilename = @options[:INPUT_FILE]

  definitionHash = parseInputFile(inputFilename)

  if @options[:CONVERT]

    outputFilename = @options[:OUTPUT_FILE]

    if inputFilename.end_with?("csv")
      YMLSerializer.new.serializeHashToYML(definitionHash, outputFilename)
    elsif inputFilename.end_with?("yml")
      serializeHashToCSV(definitionHash, outputFilename)
    end

    unless outputFilename.nil?
      puts "Converted #{inputFilename} to #{outputFilename}"
    end

    exit 0
  end

  # prepare definitions
  prepareDefinitions(definitionHash)

  if @options[:MIGRATION]
    writeMigrationFile(definitionHash, @options[:OUTPUT_FILE])
  end

  unless @options[:CONVERT] || @options[:MIGRATION]
    writeContainerFile(definitionHash, @options[:OUTPUT_FILE])
  end
end

def parseInputFile(inputFilename)
  if inputFilename.end_with?("csv")
    return CSVParser.new.parseCSV(inputFilename)
  elsif inputFilename.end_with?("yml")
    return YMLParser.new.parseYML(inputFilename)
  else
    puts "unknown input format for file #{inputFilename}"
    exit
  end
end

def templatesFolder
  File.expand_path(File.dirname(__FILE__))
end

def writeContainerFile(inputHash, outputFilename)
  @contentArray = inputHash[:DEFINITIONS]
  @dependencies = inputHash[:DEPENDENCIES]

  code = ERB.new(File.read("#{templatesFolder()}/container.erb"), nil, "-").result

  if outputFilename.nil?
    puts code
  else
    File.open(outputFilename, 'w') do |fileToWriteTo|
      fileToWriteTo.puts code
      puts "Generated code in #{outputFilename}"
    end
  end

end

def writeMigrationFile(inputHash, outputFilename)
  @migrationArray = []

  inputHash[:DEFINITIONS].each do |definition|
    registerFunctionCallWithoutLastComma = definition[:registerFunctionCall].reverse.sub(",", "").reverse

    migrationHash = {
      :resolveFunctionSignatureRegex => Shellwords.escape(".#{definition[:resolveFunctionSignature].split("->").first.strip}"),
      :resolveFunctionCall => Shellwords.escape("#{definition[:resolveFunctionCall]})!"),
      :registerFunctionSignatureRegex => Shellwords.escape(".#{definition[:registerFunctionSignature].split("(").first}"),
      :registerFunctionCall => Shellwords.escape("#{registerFunctionCallWithoutLastComma})")
    }

    @migrationArray.push migrationHash
  end

  migrationCode = ERB.new(File.read("#{templatesFolder()}/migration.erb"), nil, "-").result

  if outputFilename.nil?
    puts migrationCode
  else
    migrationFileName = "#{outputFilename}.migration.sh"
    File.open(migrationFileName, 'w') do |fileToWriteTo|
      fileToWriteTo.puts migrationCode
      puts "Generated migration code in #{migrationFileName}"
    end
  end

end

def prepareDefinitions(hash)
  definitions = hash[:DEFINITIONS]

  definitions.each do | definition |
    name = definition[:name]

    hasNoName = (name.nil? || name.empty?)
    argumentHashes = definition[:arguments]

    registerFunctionSignature = "register"
    registerFunctionSignature << definition[:targetClassName]
    registerFunctionSignature << "_#{name}" unless hasNoName
    registerFunctionSignature << "(registerClosure: (resolver: ResolverType"
    registerFunctionSignature << ", " unless (argumentHashes.nil? || argumentHashes.empty?)
    registerFunctionSignature << argumentHashes.map {|a| "#{a[:argumentName]}: #{a[:argumentType]}"}.join(", ") unless (argumentHashes.nil? || argumentHashes.empty?)
    registerFunctionSignature << ") -> (#{definition[:targetClass]})) -> ServiceEntry<#{definition[:baseClass]}>"

    registerFunctionCall = ".register("
    registerFunctionCall << "#{definition[:baseClass]}.self,"
    registerFunctionCall << " name: \"#{name}\"," unless hasNoName

    resolveFunctionSignature = "resolve"
    resolveFunctionSignature << definition[:targetClassName]
    resolveFunctionSignature << "_#{name}" unless hasNoName
    resolveFunctionSignature << "("
    resolveFunctionSignature << argumentHashes.each_with_index.map {|a,i| "#{a[:argumentName] + ' ' if i==0}#{a[:argumentName]}: #{a[:argumentType]}"}.join(", ") unless (argumentHashes.nil? || argumentHashes.empty?)
    resolveFunctionSignature << ") -> #{definition[:targetClass]}"

    resolveFunctionCall = ".resolve("
    resolveFunctionCall << "#{definition[:baseClass]}.self"
    resolveFunctionCall << ", name: \"#{name}\"" unless hasNoName

    definition[:resolveFunctionSignature] = resolveFunctionSignature
    definition[:resolveFunctionCall] = resolveFunctionCall
    definition[:registerFunctionSignature] = registerFunctionSignature
    definition[:registerFunctionCall] = registerFunctionCall
  end
end

def serializeHashToCSV(hash, outputFilename)
  @contentArray = hash[:DEFINITIONS]
  @dependencies = hash[:DEPENDENCIES]

  code = ERB.new(File.read("#{templatesFolder}/csv.erb"), nil, "-").result

  if outputFilename.nil?
    puts code
  else
    File.open(outputFilename, 'w') do |fileToWriteTo|
      fileToWriteTo.puts code
    end
  end

end

if __FILE__ == $0
  main()
end
