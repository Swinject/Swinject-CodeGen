#!/usr/bin/env ruby
require "erb"
require "Shellwords"
require "set"
require "optparse"
require "./CSVParser"
require "./YMLParser"
require "./YMLSerializer"

@DEFAULT_OUTPUT_FILE = "containerExtension.swift"

@options = {
  :SKIP_MIGRATION  => false,
  :CONVERT  => false,
  :INPUT_FILE => nil,
  :OUTPUT_FILE => @DEFAULT_OUTPUT_FILE
}

@parser = OptionParser.new do |opts|
  opts.banner = "Usage: swinject_cg [options]"

  opts.on("-iINPUT", "--input=INPUT", "The file containing the definitions, currently only .csv is supported (separated by semicolon).") do |i|
    @options[:INPUT_FILE] = i
  end

  opts.on("-oOUTPUT", "--output=OUTPUT", "The file to write to. Default is #{@DEFAULT_OUTPUT_FILE}") do |o|
    @options[:OUTPUT_FILE] = o
  end

  opts.on("-s", "--skip_migration", "Does not generate migration.sh files.") do |v|
    @options[:SKIP_MIGRATION] = true
  end

  opts.on("-c", "--convert", "Convert the input file into the other format") do |v|
    @options[:CONVERT] = true
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end

def main
  @parser.parse!

  inputFilename = @options[:INPUT_FILE]

  definitionHash = parseInputFile(inputFilename)

  if @options[:CONVERT]
    if inputFilename.end_with?("csv")
      YMLSerializer.new.serializeHashToYML(definitionHash, "#{inputFilename}.yml")
    elsif inputFilename.end_with?("yml")
      serializeHashToCSV(definitionHash, "#{inputFilename}.csv")
    end
  end

  # prepare definitions
  prepareDefinitions(definitionHash)

  writeContainerFile(definitionHash, @options[:OUTPUT_FILE])

  unless @options[:SKIP_MIGRATION]
    writeMigrationFile(definitionHash, @options[:OUTPUT_FILE])
  end
end

def parseInputFile(inputFilename)
  if inputFilename.end_with?("csv")
    return CSVParser.new.parseCSV(inputFilename)
  elsif inputFilename.end_with?("yml")
    return YMLParser.new.parseYML(inputFilename)
  else
    puts "unknown input format for file #{inputFilename}"
    exit
  end
end

def templatesFolder
  File.expand_path(File.dirname(__FILE__))
end

def writeContainerFile(inputHash, outputFilename)
  @contentArray = inputHash[:DEFINITIONS]
  @dependencies = inputHash[:DEPENDENCIES]

  fileToWriteTo = File.open(outputFilename, 'w')
  fileToWriteTo.puts ERB.new(File.read("#{templatesFolder()}/container.erb"), nil, "-").result
  puts "Generated code in #{outputFilename}"
  fileToWriteTo.close
end

def writeMigrationFile(inputHash, outputFilename)
  @migrationArray = []

  inputHash[:DEFINITIONS].each do |definition|
    registerFunctionCallWithoutLastComma = definition[:registerFunctionCall].reverse.sub(",", "").reverse

    migrationHash = {
      :resolveFunctionSignatureRegex => Shellwords.escape(".#{definition[:resolveFunctionSignature].split("->").first.strip}"),
      :resolveFunctionCall => Shellwords.escape("#{definition[:resolveFunctionCall]})!"),
      :registerFunctionSignatureRegex => Shellwords.escape(".#{definition[:registerFunctionSignature].split("(").first}"),
      :registerFunctionCall => Shellwords.escape("#{registerFunctionCallWithoutLastComma})")
    }

    @migrationArray.push migrationHash
  end

  migrationFileName = "#{outputFilename}.migration.sh"
  migrationFileToWriteTo = File.open(migrationFileName, 'w')
  migrationFileToWriteTo.puts ERB.new(File.read("#{templatesFolder()}/migration.erb"), nil, "-").result
  puts "Generated migration code in #{migrationFileName}"
  migrationFileToWriteTo.close
end

def prepareDefinitions(hash)
  definitions = hash[:DEFINITIONS]

  definitions.each do | definition |
    name = definition[:name]

    hasNoName = (name.nil? || name.empty?)
    argumentHashes = definition[:arguments]

    registerFunctionSignature = "register"
    registerFunctionSignature = registerFunctionSignature + definition[:targetClassName]
    registerFunctionSignature = registerFunctionSignature + "_#{name}" unless hasNoName
    registerFunctionSignature = registerFunctionSignature + "(registerClosure: (resolver: ResolverType"
    registerFunctionSignature = registerFunctionSignature + ", " unless (argumentHashes.nil? || argumentHashes.empty?)
    registerFunctionSignature = registerFunctionSignature + argumentHashes.map {|a| "#{a[:argumentName]}: #{a[:argumentType]}"}.join(", ") unless (argumentHashes.nil? || argumentHashes.empty?)
    registerFunctionSignature = registerFunctionSignature + ") -> (#{definition[:targetClass]})) -> ServiceEntry<#{definition[:baseClass]}>"

    registerFunctionCall = ".register("
    registerFunctionCall = registerFunctionCall + "#{definition[:baseClass]}.self,"
    registerFunctionCall = registerFunctionCall + " name: \"#{name}\"," unless hasNoName

    resolveFunctionSignature = "resolve"
    resolveFunctionSignature = resolveFunctionSignature + definition[:targetClassName]
    resolveFunctionSignature = resolveFunctionSignature + "_#{name}" unless hasNoName
    resolveFunctionSignature = resolveFunctionSignature + "("
    resolveFunctionSignature = resolveFunctionSignature + argumentHashes.map {|a| "#{a[:argumentName]}: #{a[:argumentType]}"}.join(", ") unless (argumentHashes.nil? || argumentHashes.empty?)
    resolveFunctionSignature = resolveFunctionSignature + ") -> #{definition[:targetClass]}"

    resolveFunctionCall = ".resolve("
    resolveFunctionCall = resolveFunctionCall + "#{definition[:baseClass]}.self"
    resolveFunctionCall = resolveFunctionCall + ", name: \"#{name}\"" unless hasNoName

    definition[:resolveFunctionSignature] = resolveFunctionSignature
    definition[:resolveFunctionCall] = resolveFunctionCall
    definition[:registerFunctionSignature] = registerFunctionSignature
    definition[:registerFunctionCall] = registerFunctionCall
  end
end

def serializeHashToCSV(hash, outputFilename)
  @contentArray = hash[:DEFINITIONS]
  @dependencies = hash[:DEPENDENCIES]

  fileToWriteTo = File.open(outputFilename, 'w')
  fileToWriteTo.puts ERB.new(File.read("#{templatesFolder}/csv.erb"), nil, "-").result
  fileToWriteTo.close
end

main()
